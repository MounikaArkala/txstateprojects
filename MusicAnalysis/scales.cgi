#!/usr/local/bin/python
# -*- coding: cp1252 -*-
#!"C:/python26/python.exe"

import os, cgi
from libs import structure
from musiclib import all_notes

filename = "./calcscales"
linelen = 10

# Debug code, shouldn't be included unless testing.
import cgitb
cgitb.enable()
    
def get_scale(note, intervals):
    """ pass it a note and a set of intervals and it will generate the scale.
    eg. note 5 and scale 2,2,3,1,2 would generate
    5,7,9,0,1,3."""
    result = [note]
    for i in intervals:
        result.append((result[-1] + i) % 12)
    return result
    
    
def generate_support_files():
    #check if we need to recreate all_scales.txt and scales.py and filters.py, either
    #because they don't exist or because they're older.
    if not os.path.exists("scales"):
        os.mkdir("scales")
    if not os.path.exists("scales/all_scales.txt") \
       or not os.path.exists("scales/scales.py") \
       or not os.path.exists("scales/filters.py") \
       or os.path.getmtime("scales/all_scales.txt") < os.path.getmtime("scaleslib.py") \
       or os.path.getmtime("scales/scales.py") < os.path.getmtime("scaleslib.py") \
       or os.path.getmtime("scales/filters.py") < os.path.getmtime("scaleslib.py"):
       
        from scaleslib import scales
        scalenames = scales.keys()
        scalenames.sort()
        allscales_file = open("scales/all_scales.txt", "w")
        filters_file = open("scales/filters.py", "w")
        otherscales_file = open("scales/scales.py", "w")
        filters_file.write("# -*- coding: cp1252 -*-\n")
        filters_file.write("#This file is automatically generated!  Modifications will be deleted!\n")
        otherscales_file.write("# -*- coding: cp1252 -*-\n")
        otherscales_file.write("#This file is automatically generated!  Modifications will be deleted!\n")
        otherscales_file.write("scales = [ \\\n")
        
        #get all the possible filters into a list.
        filters = []
        for scale in scalenames:
            filters.extend(scales[scale][1])
        #remove all duplicates from the list so we have just the unique filters.
        filters = list(set(filters))
        filters.sort()
        #write out the filters list to the file.
        filters_file.write("filters = " + repr(filters))
        
        #get all the possible scales into the file.
        for scale in scalenames:
            otherscales_file.write("('%s', %s, %s),\n" % (scale, scales[scale][0], scales[scale][1]))
        otherscales_file.write("]\n")
        
        
        for scale in scalenames:
            allscales_file.write(str(sum([2**filters.index(i) for i in scales[scale][1]])))
            allscales_file.write("\n")
            for i in range(12):
                allscales_file.write(" ".join([str(i) for i in get_scale(i, scales[scale][0])]))
                allscales_file.write("\n")
       

        allscales_file.close()
        filters_file.close()
        otherscales_file.close()


#it just uses this encoding because it doesn't know how to refer to items in a scale
#(eg. is an item a Eb or a D#?  It depends on the scale.
#but this information is not encoded in the scale database, so it uses defaults.
default_encoding = {0:"&nbsp;&nbsp;A&nbsp;&nbsp;", 1:"A#/Bb", 2:"B&nbsp;/Cb", 3:"B#/&nbsp;C", 4:"C#/Db",
                    5:"&nbsp;&nbsp;D&nbsp;&nbsp;", 6:"D#/Eb", 7:"E&nbsp;/Fb", 8:"E#/&nbsp;F", 9:"F#/Gb", 10:"&nbsp;&nbsp;G&nbsp;&nbsp;", 11:"G#/Ab"}

def pretty(notes, encoding):
    ' notes is int array, encoding is a dict such as {0:"A", 1:"A#" ... 11:"G#"}'
    return " ".join([encoding[i] for i in notes])

    

# Create instance of FieldStorage 
form = cgi.FieldStorage() 

def printPage():
    global notes, wrap, order, consecutive, linelen
    #this is a function so it can be "return'd" from.
    #it's a bit of an exploitation of a function for a control flow advantage but
    #I feel it greatly simplifies the code in this case.
    temp = []
    for i in notes.split():
        i = i.strip()
        i = i[0].upper() + i[1:].lower()
        try:
            if not all_notes[i] in temp:
                temp.append(all_notes[i])
        except KeyError:
            print "You entered an invalid note: %s" % i
            return
    
    notes = temp
    print '<div id="scalesdiv">'
    print '<table class="scales">'
    print '<tr class="scales">'
    print '<th scope="col" class="scales">Scale Name</th>'
    print '<th scope="col" class="scales">Music</th>'
    print '<th scope="col" class="scales">Matching Scales</th></tr>'
    
    
    from scales.scales import scales
    from scales.filters import filters
    args = []
    if order:
        args.append("1")
        if wrap:
            args.append("1")
        else:
            args.append("0")
        if consecutive:
            args.append("1")
        else:
            args.append("0")
    else:
        args = ["0", "0", "0"]
    filters_combined = 0
    for i in range(len(filters)):
        try:
            order = (form.getvalue(filters[i]).strip().lower() == "on")
        except:
            order = False
        if order:
            filters_combined += 2**i
    os.chdir("scales")
    out = os.popen('%s %s %s "%s"' % (filename, " ".join(args), filters_combined, " ".join([str(i) for i in notes]))).readlines()
    os.chdir("..")
    previous = int(out[0]) / 12
    matching = [int(out[0]) % 12]
        
    for result in out[1:]:
        try:
            result_int = int(result)
            target = result_int / 12
            shift = result_int % 12
            if target == previous:
                matching.append(shift)
            else:           
                print '<tr class="scales">'
                print '<td class="scales">%s</td><td class="scales">%s</td>' % (scales[previous][0], ", ".join(scales[previous][2]))
                print '<td class="scales">'
                for starting_note in matching:
                    scale = get_scale(starting_note, scales[previous][1])
                    print '<table class="scale"><tr class="scale">'
                    length = 0
                    for note in scale:
                        if length >= linelen:
                            print '</tr><tr class="scale">'
                            length = 0
                        length += 1
                        if note in notes:
                            print '<td class="scaley">%s</td>' % default_encoding[note]
                        else:
                            print '<td class="scalen">%s</td>' % default_encoding[note]
                    print '</tr></table>\n'
                print '</td></tr>'
                previous = target     
                matching = [shift]
        except:
            pass#print result
            
            #scales result table.
            
    print '</table>'

    print '</div> <!-- ~scalesdiv -->'
            
    """
    
    #convert notes from strings to their correct corresponding note (integer).
    notes = []
    for i in temp.split():
        i = i.strip()
        i = i[0].upper() + i[1:].lower()
        
        try:
            if not all_notes[i] in notes:
                notes.append(all_notes[i])
        except KeyError:
            print "You entered an invalid note: %s" % i
            return

    groups = []
    for scale in scales:
        for group in scales[scale][1]:
            groups.append(group)
    groups = list(set(groups))
    groups.sort()

    if page.strip().lower() == "main":# print out the filter list, but don't do any filtering.
    
        print "using notes: %s <br /><br />" % pretty(notes, default_encoding)
        
        #filter list.
        print '<table class="filters">'
        print '<tr class="filters"><th class="filters" colspan=50>Music Filter</td></tr>'
        print '<tr class="filters">'
        for i, group in enumerate(groups):
            print '<td class="filters"><input type="checkbox" class="filterbox" \
            checked id="filter%i" onClick="updateScales();">%s</input></td>' % (i, group)
        print '</tr></table>'
        print '<input type="hidden" id="grps" value="%s" />' % len(groups)
        
        print '<div id="scalesdiv">'

        #scale filter
        scalenames = scales.keys()
        
    elif page == "filtered": #just print out the (filtered) scales table.
        
        valid_groups = []
        for i, group in enumerate(groups):
            try:
                temp = form.getvalue("filter%i" % i).strip()
                if temp == "true":
                    valid_groups.append(group)
            except:
                print "Error processing music filters."
                return
                
        valid_groups = frozenset(valid_groups)
                
        scalenames = []
        for scale in scales:
            if valid_groups.intersection(set(scales[scale][1])):
                scalenames.append(scale)


    else:
        #they specified an invalid page name.
        print "404 - Page %s could not be found!" % page
        
    #scales result table.
    print '<table class="scales">'
    print '<tr class="scales">'
    print '<th scope="col" class="scales">Scale Name</th>'
    print '<th scope="col" class="scales">Music</th>'
    print '<th scope="col" class="scales">Matching Scales</th></tr>'

    scalenames.sort()
    for scale in scalenames:
        matched = []
        for s in get_scales(scales[scale][0]):
            tempscale = []
            found = []
                
            current = 0
            
            for note in s:
                if consecutive and current > 0:
                    if current < len(notes) and note != notes[current]:
                        # if we're still looking for notes, and
                        #the current note doesn't match...
                        found = []
                        break
                        
                if order:
                # monitor the current note and only allow the note to be added if the notes are
                #in the correct order.
                    if note == notes[min(len(notes) - 1, current)]:
                        tempscale.append((note, 1))
                        # tempscale contains a tuple which lets the program know if
                        #it should highlight that note or not.
                        found.append(note)
                        current += 1
                        
                    else:
                        if note in notes:
                            tempscale.append((note, 1))
                        else:
                            tempscale.append((note, 0))
                            
                else:
                    if note in notes:
                        tempscale.append((note, 1))
                        found.append(note)
                        current += 1
                        
                    else:
                        tempscale.append((note, 0))
                        
            if len(set(found)) == len(notes): #use a set so it supports scales that repeat notes as well as those that don't.
                #it was a match, so add the scale to our list.
                matched.append(tempscale)
                
        if len(matched) > 0: # there were valid matches so print them out.
            print '<tr class="scales">'
            print '<td class="scales">%s</td><td class="scales">%s</td>' % (scale, ", ".join(scales[scale][1]))
            print '<td class="scales">'
            for item in matched:
                print '<table class="scale"><tr class="scale">'
                for note, match in item:
                    if match:
                        print '<td class="scaley">%s</td>' % default_encoding[note]
                    else:
                        print '<td class="scalen">%s</td>' % default_encoding[note]
                print '</tr></table>\n'
            print '</td></tr>'
            
    print '</table>'

    if page == "main":
        print "</div>"
    
    """

    
    
structure.print_header(title="Scales page", scripts=["scales.js"], css=["main.css", "scales.css"])
generate_support_files()

  
  
try:
    # Get data from fields
    notes = form.getvalue('notes').strip().lower()
    try:
        wrap = (form.getvalue('wrap').strip().lower() == "on")
    except:
        #it won't submit "wrap"'s value if it's not checked, so default it to False.
        wrap = False
        
    try:
        order = (form.getvalue('order').strip().lower() == "on")
    except:
        order = False
    try:
        consecutive = (form.getvalue('consec').strip().lower() == "on")
    except:
        consecutive = False
        
    printPage()
    
except:
    #main page.
    from scales.filters import filters
    structure.print_body("scales/main_1.html")
    print '<table class="filters">'
    print '<tr class="filters"><th class="filters" colspan=50>Music Filter</td></tr>'
    print '<tr class="filters">'
    for filter in filters:
        print '<td class="filters"><input type="checkbox" class="filterbox" \
        checked name="%s" id="%s">%s</input></td>' % (filter, filter, filter)
    print '</tr></table>'

    print '<div id="scalesdiv">'

    structure.print_body("scales/main_2.html")

       

structure.print_footer()