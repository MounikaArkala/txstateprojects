#!/usr/local/bin/python
# -*- coding: cp1252 -*-
#!"C:/python26/python.exe"
import os, cgi
from libs import structure
from musiclib import all_notes
pitchclass_txt = "All Pitch Classes"
filename = "./calcscales"
#filename = "calcscales.exe"
linelen = 10

# Debug code, shouldn't be included unless testing.
import cgitb
cgitb.enable()
    
def get_scale(note, intervals):
    """ pass it a note and a set of intervals and it will generate the scale.
    eg. note 5 and scale 2,2,3,1,2 would generate
    5,7,9,0,1,3."""
    result = [note]
    for i in intervals:
        result.append((result[-1] + i) % 12)
    return result
    
    
def generate_support_files():
    #check if we need to recreate all_scales.txt and scales.py and filters.py, either
    #because they don't exist or because they're older.
    if not os.path.exists("scales"):
        os.mkdir("scales")
    if not os.path.exists("scales/all_scales.txt") \
       or not os.path.exists("scales/scales.py") \
       or not os.path.exists("scales/filters.py") \
       or os.path.getmtime("scales/all_scales.txt") < os.path.getmtime("scaleslib.py") \
       or os.path.getmtime("scales/scales.py") < os.path.getmtime("scaleslib.py") \
       or os.path.getmtime("scales/filters.py") < os.path.getmtime("scaleslib.py"):
       
        from scaleslib import scales
        scalenames = scales.keys()
        scalenames.sort()
        allscales_file = open("scales/all_scales.txt", "w")
        filters_file = open("scales/filters.py", "w")
        otherscales_file = open("scales/scales.py", "w")
        filters_file.write("# -*- coding: cp1252 -*-\n")
        filters_file.write("#This file is automatically generated!  Modifications will be deleted!\n")
        otherscales_file.write("# -*- coding: cp1252 -*-\n")
        otherscales_file.write("#This file is automatically generated!  Modifications will be deleted!\n")
        otherscales_file.write("scales = [ \\\n")
        
        #get all the possible filters into a list.
        filters = []
        for scale in scalenames:
            filters.extend(scales[scale][1])
        #remove all duplicates from the list so we have just the unique filters.
        filters = list(set(filters))
        filters.sort()
        #write out the filters list to the file.
        filters_file.write("filters = " + repr(filters))
        
        #get all the possible scales into the file.
        for scale in scalenames:
            otherscales_file.write("('%s', %s, %s),\n" % (scale, scales[scale][0], scales[scale][1]))
        otherscales_file.write("]\n")
        
        
        for scale in scalenames:
            allscales_file.write(str(sum([2**filters.index(i) for i in scales[scale][1]])))
            allscales_file.write("\n")
            for i in range(12):
                allscales_file.write(" ".join([str(i) for i in get_scale(i, scales[scale][0])]))
                allscales_file.write("\n")
       

        allscales_file.close()
        filters_file.close()
        otherscales_file.close()


#it just uses this encoding because it doesn't know how to refer to items in a scale
#(eg. is an item a Eb or a D#?  It depends on the scale.
#but this information is not encoded in the scale database, so it uses defaults.
default_encoding = {0:"A", 1:"A#/Bb", 2:"B/Cb", 3:"B#/C", 4:"C#/Db",
                    5:"D", 6:"D#/Eb", 7:"E/Fb", 8:"E#/F", 9:"F#/Gb", 10:"G", 11:"G#/Ab"}

def pretty(notes, encoding):
    ' notes is int array, encoding is a dict such as {0:"A", 1:"A#" ... 11:"G#"}'
    return " ".join([encoding[i] for i in notes])

    
    
    
    
    
    
    
    
    
    

# Create instance of FieldStorage 
form = cgi.FieldStorage() 

def printPage(page):

    page = page.lower()
    global notes, wrap, order, consecutive, linelen, start, pitchclass_txt
    from scales.filters import filters

    searchfields = {"notes": "", "pitchclasses":pitchclass_txt, "wrap": "", "consec": "", "order": "", "pitchclass_class": "default-value"}
    
    
    filtertable = []
    filtertable.append('<table class="filters" id="filtertable">')
    filtertable.append('<tr class="filters"><th class="filters" colspan=50>Music Filter</td></tr>')
    filtertable.append('<tr class="filters">')

    if page == "main":
        for filter in filters:
            filtertable.append('<td class="filters"><input type="checkbox" class="filterbox" \
            checked name="%s" id="%s">%s</input></td>' % (filter, filter, filter))
		
    elif page == "result":
        
        for filter in filters:
            try:
                filter_checked = (form.getvalue(filter).strip().lower() == "on")
            except:
                filter_checked = False
            if filter_checked:
                filtertable.append('<td class="filters"><input type="checkbox" class="filterbox" \
                checked name="%s" id="%s">%s</input></td>' % (filter, filter, filter))
            else:
                filtertable.append('<td class="filters"><input type="checkbox" class="filterbox" \
                name="%s" id="%s">%s</input></td>' % (filter, filter, filter))
        
        temp = []
        for i in notes.split():
            i = i.strip()
            i = i[0].upper() + i[1:].lower()
            temp.append(i)
        searchfields["notes"] = " ".join(temp)
        
        if start:
            searchfields["pitchclasses"] = start
            searchfields["pitchclass_class"] = ""
            
        if wrap:
            searchfields["wrap"] = "checked"
        if consecutive:
            searchfields["consec"] = "checked"
        if order:
            searchfields["order"] = "checked"
    
    filtertable.append('</tr></table>')
    filtertable.append('<button class="SubmitButton" type="button" onClick="selectAll();">Select All</button>')
    filtertable.append('<button class="SubmitButton" type="button" onClick="selectNone();">Select None</button>')
    filtertable = "\n".join(filtertable)
    searchfields["filtertable"] = filtertable
    
    
    structure.print_body("scales/main.html", subdict=searchfields)
    
    if page == "main":
        structure.print_body("scales/directions.html")
        return
    
    
    
    #-- start of results generation.
    
    temp = []
    for i in notes.split():
        i = i.strip()
        i = i[0].upper() + i[1:].lower()
        try:
            if not all_notes[i] in temp:
                temp.append(all_notes[i])
        except KeyError:
            print '<h2 class="scales">You entered an invalid note: %s</h2>' % i
            return
    notes = temp
    
    
    if start:
        temp = []
        all = False
        display = []
        for i in start.split():
            i = i.strip()
            i = i[0].upper() + i[1:].lower()
            try:
                if not all_notes[i] in temp:
                    temp.append(all_notes[i])
                    display.append(i)
            except KeyError:
                all = True
                temp = range(12)
                print '<h2 class="scales">Pitch class "%s" not recognized!</h2>' % i
                break
    else:
        all = True
     
    """
    if all:
        print '<p class="scales">Searching all starting pitch classes</p>'
    else:
        if len(display) == 1:
            print '<p class="scales">Only searching scales that start with pitch class %s</p>' % ", ".join(display)
        else:
            print '<p class="scales">Only searching scales that start with pitch classes %s</p>' % ", ".join(display)
    """
    start = temp
    
    from scales.scales import scales
    args = []
    if order:
        args.append("1")
        if wrap:
            args.append("1")
        else:
            args.append("0")
    else:
        args = ["0", "0"]
    if consecutive:
        args.append("1")
    else:
        args.append("0")
    filters_combined = 0
    for i in range(len(filters)):
        try:
            filter_active = (form.getvalue(filters[i]).strip().lower() == "on")
        except:
            filter_active = False
        if filter_active:
            filters_combined += 2**i
    os.chdir("scales")
    out = os.popen('%s %s %s "%s" "%s"' % (filename, " ".join(args), filters_combined, " ".join([str(i) for i in start]), " ".join([str(i) for i in notes]))).readlines()
    os.chdir("..")
    if len(out) == 0:
        print '<h2 class="scales">No scales matched that search!</h2>'
        return
        
        
    previous = int(out[0]) / 12
    matching = [int(out[0]) % 12]
    output = [] # buffer our output.
    for result in out[1:]:
        try:
            result_int = int(result)
            target = result_int / 12
            shift = result_int % 12
            if target == previous:
                matching.append(shift)
            else:           
                output.append('<tr class="scales">')
                output.append('<td class="scales">%s</td><td class="scales">%s</td>' % (scales[previous][0], ", ".join(scales[previous][2])))
                output.append('<td class="scales">')
                for starting_note in matching:
                    scale = get_scale(starting_note, scales[previous][1])
                    output.append('<table class="scale"><tr class="scale">')
                    length = 0
                    for note in scale:
                        if length >= linelen:
                            output.append('</tr><tr class="scale">')
                            length = 0
                        length += 1
                        if note in notes:
                            output.append('<td class="scaley">%s</td>' % default_encoding[note])
                        else:
                            output.append('<td class="scalen">%s</td>' % default_encoding[note])
                    output.append('</tr></table>\n')
                output.append('</td></tr>')
                previous = target     
                matching = [shift]
        except:
            pass#print result
    
    try:           
        output.append('<tr class="scales">')
        output.append('<td class="scales">%s</td><td class="scales">%s</td>' % (scales[previous][0], ", ".join(scales[previous][2])))
        output.append('<td class="scales">')
        for starting_note in matching:
            scale = get_scale(starting_note, scales[previous][1])
            output.append('<table class="scale"><tr class="scale">')
            length = 0
            for note in scale:
                if length >= linelen:
                    output.append('</tr><tr class="scale">')
                    length = 0
                length += 1
                if note in notes:
                    output.append('<td class="scaley">%s</td>' % default_encoding[note])
                else:
                    output.append('<td class="scalen">%s</td>' % default_encoding[note])
            output.append('</tr></table>\n')
        output.append('</td></tr>')
    except:
        pass
    
    if len(output) == 0:
        print '<h2 class="scales">No scales matched that search!</h2>'
        return
    
    print '<div id="scalesdiv">'
    print '<table class="scales">'
    print '<tr class="scales">'
    print '<th scope="col" class="scales">Scale Name</th>'
    print '<th scope="col" class="scales">Music</th>'
    print '<th scope="col" class="scales">Matching Scales</th></tr>'
    
    print "\n".join(output)
            
    print '</table>'

    print '</div> <!-- ~scalesdiv -->'
    
    
    
    
    
structure.print_header(title="Scales Identification in Music Analysis: Web-Based Analytical Tool for the Matching of Scalar Pitch Collections by Nico Schuler and Luke Paireepinart",
                       scripts=["main.js", "scales.js"], css=["main.css", "scales.css"])
generate_support_files()
  
try:
    # Get data from fields
    notes = form.getvalue('notes').strip().lower()
    try:
        start = form.getvalue('start').strip()
        if start.lower() == pitchclass_txt.lower():
            start = None
    except:
        start = None
    try:
        wrap = (form.getvalue('wrap').strip().lower() == "on")
    except:
        wrap = False
        
    try:
        order = (form.getvalue('order').strip().lower() == "on")
    except:
        order = False
    try:
        consecutive = (form.getvalue('consec').strip().lower() == "on")
    except:
        consecutive = False
    try:
        printPage("result")
    except:
        pass
    
except:
	printPage("main")
       

structure.print_footer()